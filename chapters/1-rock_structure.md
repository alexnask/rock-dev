## Chapter 1: rock's structure

### rock's parts

rock is divided into three basic components: the frontend, the middle-end and the backend.  

The frontend takes care of parsing options passed to rock, finding out what files we are compiling and how and parsing them into an Abstract Syntax Tree (AST), using [nagaqueen](https://github.com/ooc-lang/nagaqueen).  

The middle-end, commonly referred to as the semantic analysis phase in other compilers, then takes the AST and runs checks on it.  
Its purpose is to report any kind of semantic error, execute type inference, replace syntactic sugar with actual ooc constructs and link every use of a type or variable with its actual declaration.  

The backend's job is to take the modified AST from the middle-end phase and translate it into a target language.  
The default backend is the C99 cnaughty backend.  
Other available backends are the JSON backend, which dumps information about declarations into JSON files and the Lua backend, which generates Lua bindings of the ooc code.  

Finally, the frontend takes care of compiling, generating some Makefile or doing any other additional task after the translation.  
The whole process is orchestrated through what are called "drivers".  

### Building rock

rock is a bootstrapping compiler.  
That means that it is written in the same language as it is meant to compile (in this case, ooc).  
The whole concept can be confusing to someone that is not used to it but is pretty simple in reality.  

To build rock without having an existing ooc compiler on your system, the makefile includes a rule, "rescue", that goes ahead and downloads a copy of recent rock C sources generated by rock itself, which we call a bootstrap.  
Those are then compiled and produce a version of rock we call c_rock.  
c_rock then goes ahead and compiles rock from the ooc sources.  

This process _does not_ guarantee that the resulting rock binary can compile rock itself.  
An additional compilation of rock (after running `make clean`) with rock itself guarantees that the current ooc sources of rock can compile rock itself but not that the resulting binary will generate correct code.  

In general, after making some changes to rock itself, the _only_ way to guarantee the resulting compiler can compile itself is the following process:  

`make clean && make self`  
Clean up our build, make our modified rock version from the unmodified rock version.  
We now have a modified version but we do not know whether it can compile itself.  

`make clean && make self`  
Clean up our build, make our modified rock from our modified rock.  
We now have a modified version built from the modified version itself.  
This __does not__ however guarantee that __our new binary generates correct code__.  
There are some insidious bugs that could result in this binary generating incorrect code.  

`make clean && make self`
Clean up our build, make our modified rock from our modified rock binary that was made with our modified rock binary.  
We now have a modified rock binary that is guaranteed to be able to compile itself.  

To summarize, making sure that a change in rock sources results in a rock binary that can compile itself, one must do:  
```sh
make clean && make self && make clean && make self && make clean && make self
```

On windows, `make self` will fail at link phase because the executable file is locked while it is running and the linker cannot obtain write permissions.  
To get around that issue, make a copy of the rock executable (for example, cp bin/rock.exe bin/rock2.exe).  
Then, instead of running make self, run:  

```sh
OOC=bin/rock2.exe make self
```

You should copy your rock executable before and after every `make self` call to make sure it is up to date.  


After you have made sure your change did not leave rock unable to bootstrap and are satisfies with your changes, you should always check if the test suite still passes.  

To do this, you will need [sam](https://github.com/ooc-lang/sam).  

After following the instructions and installing sam, you can go ahead and call `sam test` in the rock main directory.  
At the time of writing this, the test suite is about 180 tests strong and takes about 2 minutes to complete.  
There is a known win32 Boehm GC bug that causes 2 sdk tests to fail.  

### nagaqueen and rock

nagaqueen is the name of the official ooc grammar.  
You __do not__ need to worry about nagaqueen unless you have the intention of modifying ooc grammar.  

It is written in a PEG dialect called [greg](https://github.com/ooc-lang/greg).  
To build nagaqueen, you will need greg in your PATH.  

If your nagaqueen folder sits alongside your rock folder, than you can directly use `make grammar` in your rock folder to generate a new version of nagaqueen and copy it in rock.  

Otherwise, use `greg /path/to/nagaqueen/grammar/nagaqueen.leg > NagaQueen.c` and `cp NagaQueen.c /path/to/rock/source/rock/frontend/NagaQueen.c`.  

__Note: Grammar changes introduced in a new version of rock should not appear in the same version's rock source.__  

### The frontend

rock's frontend is essentially the system that keeps everything together.  
Its job is to look at the arguments passed to rock and make decisions as to what files to go over and how.  

Let's have a look at the basic parts of the frontend and their function:  

- CommandLine: Takes a list of arguments passed to rock, parses them and launches the various subsystems in order.
- BuildParams: Built by the CommandLine. Holds information on rock's path, backend and driver to use, defined symbols, toolchain to use for C compilation, etc.  
- Driver: The driver takes care of collecting dependencies (libraries and sources), calling the compiler (if any) and generating any additional files, like a Makefile or Android.mk  
At the time of writing this, here is a list of available drivers:  
    * AndroidDriver: Generates C sources, generates Android build files.
    * CMakeDriver: Generates C sources, generates CMakeLists.txt
    * DummyDriver: Only generates C sources
    * MakeDriver: Generates C sources, generates Makefile (note: used to generate bootstraps)
    * SequenceDriver: Generates C sources, compiles them and links them into an executable (note: default driver)
- Archive: Reads and/or writes .cacheinfo files that contain all symbols defined in an ooc library, as well as the generated timestamp.  
Archives are used for incremental compilation by checking whether a library has been modified since the last time a .cacheinfo file was generated.  
- Compiler: Holds a path to the C compiler to use, can be invoked on a file.  
- PkgConfigFrontend: Can call into pkg-config to get include and library paths for C libraries (specified by usefiles).  
- PathList: Takes care of finding ooc modules imported in out project and caches them.
- Flags: Builds the flags to pass to the C compiler.
- Target: Holds information on the target we are building for.
- Token: A token is essentially a piece of text from a parsed module. It is used to print nice, clang-style error messages during semantic analysis.
- AstBuilder: Calls into NagaQueen.c to parse an ooc file and returns a Module object, which is the root of the file's AST.


### The middle-end

rock's middle-end is probably the biggest part of the compiler.  
Its job is to take the original AST provided by the frontend and run a process which detects type errors, does type inference, replaces syntactic sugar etc.  

The middle-end is mostly made up of AST classes, which also contain the logic needed to "resolve" them (that is, find their declaration, if we are talking about a variable, function or type, do typechecking, type inference etc.).  
In addition to that, some functionality can be located in the `algo` folder.  

Currently, the algorithm to determine an automatic return statement (last expression in function), find the common root of a type and do numeric promotion as well as classifying imports as loose or tight are located there.  

Finally, some basic constructs we use to resolve are defined in the `tinker` folder:  

- Errors.ooc: Error handling, nothing too interesting.
- Resolver: The resolver goes over a Module's AST and asks every node to be resolved.  
It also holds some state on whether the node requested for the whole process to be restarted, with a reason (called wholeAgain).
- Response: An enum returned by every node when resolved (OK or LOOP).  
- Tinkerer: The Tinkerer holds a list of Modules to resolve.  
To do that, it creates a list of Resolvers for those Modules, and launches them on the Modules.  
Each time a Resolver didn't manage to resolve the whole Module, it increments a round counter and tries again.  
If the round counter goes over a certain limit, it errors out, assuming we were caught in some infinite loop.  
- Trail: The Trail is a stack of AST Nodes that the Resolver is currently processing.  
When requesting to resolve a child Node, Nodes usually push themselves on the trail and pop themselves when done.  
This is critical for rock to function, since Nodes don't hold parent information.  
This allows us to look into the context of a Node to find it's declaration, type or other information.

### The cnaughty backend

cnaughty is the most frequently used backend.  
In fact, it is currently the only backend that can be used to eventually compile a program and parts of the language are specifically tailored for it.  

In fact, many AST constructs are not representable in ooc code (comma sequences, anonymous structures etc.) but are designed to be easily translated by the cnaughty backend.  

The backend uses the visitor pattern to go through every module and generates three files for each.  
One is the resulting .c source file and the other two are .h header files.  
One of the header files contains structure declarations while the other one only forward declares types.  
The correct header file is included depending on whether the original import was found to be tight or loose.  

Translation from the AST to C99 is pretty straightforward and most nodes are translated like you would expect them to.